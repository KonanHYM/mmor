print (mystring)
print ( mystring)
mystring -< "hello world"
mystring = "hello world"
setwd("/Users/Konan/Desktop/github/mmor/quant")
BTCUSDT<-read.csv("BTCUSDT.csv", stringsAsFactors =F)
BTCUSDT$Date<-as.Date(BTCUSDT$time)
str(BTCUSDT)
Return_p<-diff(log(BTCUSDT$close_price))
plot(Return_p)
Close.ts<-ts(BTCUSDT$close_price,start=c(2015),freq=250)
Close.ts
Return.ts<-ts(Return_p,start=c(2015),freq=250)
par(mfrow=c(2,1))
plot(Close.ts,type="l",main="(a) Daily Closing Price of Bitcoin",xlab="Date", ylab="Price", cex.main=0.95,las=1)
plot(Return.ts,type="l",main="(b) Daily Rate of Return of Bitcoin",xlab="Date", ylab="Rate", cex.main=0.95, las=1)
library(tseries)
summary(Return_p)
hist(Return_p)   ##直方图
n<-length(Return_p)
u<-sum(Return_p)/n   ### 求均值
e<-sqrt(sum((Return_p-u)^2)/(n-1))  # 求标准差
s<-sum((Return_p-u)^3)/((n-1)*e^3)  # 求偏度
k<-sum((Return_p-u)^4)/((n-1)*e^4)  # 求峰度
jarque.bera.test(Return_p)         # JB正态性检验（拒绝原假设：收益率是正态分布）
par(mfrow=c(2,1))
acf(Return_p,main='',xlab='Lag (a)',ylab='ACF',las=1) #画自相关图
title(main='(a) the ACF of Return',cex.main=0.95)  #为图形加标题，并设置标题大小
pacf(Return_p,main='',xlab='Lag (b)',ylab='PACF',las=1) #画偏自相关图
title(main='(b) the PACF of Return',cex.main=0.95)
acf2(Return_p)
library(astsa)
acf2(Return_p)
par(mfrow=c(2,1))
Return_p.square<-Return_p^2
acf(Return_p.square,main='',xlab='Lag (c)',ylab='ACF',las=1)
title(main='(a) the ACF of Return Square',cex.main=0.95)
pacf(Return_p.square,main='',xlab='Lag (d)',ylab='PACF',las=1)
title(main='(b) the PACF of Return Square',cex.main=0.95)
library(zoo)
library(tseries)
ArchTest <- function (x, lags=12, demean = FALSE)
{
# Capture name of x for documentation in the output
xName <- deparse(substitute(x))
#
x <- as.vector(x)
if(demean) x <- scale(x, center = TRUE, scale = FALSE)
#
lags <- lags + 1
mat <- embed(x^2, lags)
arch.lm <- summary(lm(mat[, 1] ~ mat[, -1]))
STATISTIC <- arch.lm$r.squared * length(resid(arch.lm))
names(STATISTIC) <- "Chi-squared"
PARAMETER <- lags - 1
names(PARAMETER) <- "df"
PVAL <- 1 - pchisq(STATISTIC, df = PARAMETER)
METHOD <- "ARCH LM-test;  Null hypothesis:  no ARCH effects"
result <- list(statistic = STATISTIC, parameter = PARAMETER,
p.value = PVAL, method = METHOD, data.name =
xName)
class(result) <- "htest"
return(result)
}
ArchTest(Return_p,lag=12)
library(timeDate)
library(timeSeries)
library(fBasics)
library(fGarch)
m1<-garchFit(~1+garch(1,1),data=Return_p,trace=F) #拟合GARCH（1,1）模型
summary(m1)    #显示模型的详细拟合结果
m2<-garchFit(~1+garch(1,2),data=Return_p,trace=F) #拟合GARCH（1,2）模型
m3<-garchFit(~1+garch(2,1),data=Return_p,trace=F) #拟合GARCH（2,1）模型
m4<-garchFit(~1+garch(2,2),data=Return_p,trace=F) #拟合GARCH（2,2）模型
summary(m2)
summary(m3)
summary(m4)
resi<-residuals(m1,standardize=T)   #获得标准化残差
res<-ts(resi,frequency=250,start=c(2000))
plot(res,xlab='Date',ylab='st.resi',type='l')
par(mfcol=c(2,2))
acf(resi,lag=24)
acf(resi^2,lag=24)
pacf(resi,lag=24)
pacf(resi^2,lag=24)
Box.test(resi^2,lag=10,type='Ljung')  #残差平方的滞后10阶自相关检验
Box.test(resi^2,lag=15,type='Ljung')  #残差平方的滞后15阶自相关检验
Box.test(resi^2,lag=20,type='Ljung')  #残差平方的滞后20阶自相关检验
library(rugarch)
spec1=ugarchspec(variance.model=list(model="sGARCH"), mean.model=list(armaOrder=c(1,1)))
fit1<-ugarchfit(data=Return_p,spec=spec1)
fit1
forc_fit1 = ugarchforecast(fit1, n.head = 20)
forc_fit1
spec2=ugarchspec(variance.model=list(model="sGARCH"), mean.model=list(armaOrder=c(1,1),archm=TRUE))
fit2=ugarchfit(data=Return_p,spec=spec2)
fit2
spec3=ugarchspec(variance.model=list(model="eGARCH"), mean.model=list(armaOrder=c(1,1)))
fit3=ugarchfit(data=Return_p,spec=spec3)
fit3
spec4=ugarchspec(variance.model=list(model="gjrGARCH"), mean.model=list(armaOrder=c(1,1)))
fit4=ugarchfit(data=Return_p,spec=spec4)
fit4
k<-sum((Return_p-u)^4)/((n-1)*e^4)  # 求峰度
k
library(forecast)
model.sel<-auto.arima(Return_p, trace = TRUE, ic="bic")
m1<-garchFit(~arma(0,0)+garch(1,1),data=Return_p,trace=F) #拟合GARCH（1,1）模型
summary(m1)    #显示模型的详细拟合结果
m2<-garchFit(~arma(0,0)+garch(1,2),data=Return_p,trace=F) #拟合GARCH（1,2）模型
m3<-garchFit(~arma(0,0)+garch(2,1),data=Return_p,trace=F) #拟合GARCH（2,1）模型
m4<-garchFit(~arma(0,0)+garch(2,2),data=Return_p,trace=F) #拟合GARCH（2,2）模型
summary(m2)
summary(m3)
summary(m4)
resi<-residuals(m1,standardize=T)   #获得标准化残差
res<-ts(resi,frequency=250,start=c(2000))
plot(res,xlab='Date',ylab='st.resi',type='l')
summary(m1)    #显示模型的详细拟合结果
model.sel<-auto.arima(Return_p, trace = TRUE, ic="bic")#选取最优的ARMA模型 （0，0）
model.sel
model.sel<-auto.arima(Return_p, trace = TRUE, ic="bic")#选取最优的ARMA模型 （0，0）
model.sel
forc_fit1
library(ggplot2)
p <- ggplot(forc_fit1, aes(x=time, y=price, colour=cyl)) +geom_point()
typeof(forc_fit1)
predict_list = predict(m1, n.ahead = 10)
predict_list
predict_list = predict(m1, n.ahead = 10, trace = TRUE)
predict_list
predict_list = predict(m1, n.ahead = 10, plot = TRUE)
ArchTest(Return_p,lag=12)
